/*
---       `funlab' 0.0.0 (c) 1978 by Marcin 'Amok' Konarski         ---

	rc_options.c - this file is integral part of `funlab' project.

	i.  You may not make any changes in Copyright information.
	ii. You must attach Copyright information to any part of every copy
	    of this software.

Copyright:

 You are free to use this program as is, you can redistribute binary
 package freely but:
  1. You can not use any part of sources of this software.
  2. You can not redistribute any part of sources of this software.
  3. No reverse engineering is allowed.
  4. If you want redistribute binary package you can not demand any fees
     for this software.
     You can not even demand cost of the carrier (CD for example).
  5. You can not include it to any commercial enterprise (for example 
     as a free add-on to payed software or payed newspaper).
 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE. Use it at your own risk.
*/

/* declarations */

/* headers */

/* For compilers that support precompilation, includes "wx/wxprec.h". */
#include <wx/wxprec.h>

/* for all others, include the necessary headers (this file is usually all you
 * need because it includes almost all "standard" wxWindows headers) */
#ifndef WX_PRECOMP
#include <wx/wx.h>
#include <wx/listctrl.h>
#endif

/* resources */
#include <wx/xrc/xmlres.h>

/* stdhapi */
#include <stdhapi.h>
M_CVSID ( "$CVSHeader$" );

#include "version.h"
#include "setup.h"
#include "renderer.h"

using namespace stdhapi::hcore;

int gui_start ( int a_iArgc, char * a_ppcArgv [ ] )
	{
	M_PROLOG
	return ( wxEntry ( a_iArgc, a_ppcArgv ) );
	M_EPILOG
	}

/* private classes */

/* Define a new frame type: this is going to be our main frame */
class HEvtHandler;
class HFrame : public wxFrame
	{
protected:
	/*{*/
	wxListCtrl * f_poList;
	HEvtHandler * f_poHandler;
	/*}*/
public:
	/*{*/
	HFrame ( void );
	virtual ~HFrame ( void );
	void layout ( void );
	/*}*/
protected:
	/*{*/
	void open ( const HString & );
	void save ( const HString & );
	void resize_list ( void );
	/*}*/
private:
	/*{*/
	/* event handlers (these functions should _not_ be virtual) */
	void on_size ( wxSizeEvent& );
	void on_new ( wxCommandEvent & );
	void on_open ( wxCommandEvent & );
	void on_save ( wxCommandEvent & );
	void on_quit ( wxCommandEvent & );
	void on_about ( wxCommandEvent & );
	/*}*/
private:
	/*{*/
	/* any class wishing to process wxWindows events must use this macro */
	DECLARE_EVENT_TABLE ( )
	DECLARE_DYNAMIC_CLASS ( HFrame );
	HFrame ( const HFrame & );
	HFrame & operator = ( const HFrame & );
	/*}*/
	};
IMPLEMENT_DYNAMIC_CLASS ( HFrame,  wxFrame )

/* Define a new application type, each program should derive a class from wxApp */
class HApp : public wxApp
	{
protected:
	/*{*/
	HFrame * f_poFrame;
	/*}*/
public:
	/*{*/
	HApp ( void );
	virtual ~HApp ( void );
	/* override base class virtuals
	 * ----------------------------
	 *  this one is called on application startup and is a good place for the app
	 *  initialization (doing it here and not in the ctor allows to have an error
	 *  return: if OnInit() returns false, the application terminates) */
	virtual bool OnInit ( void );
	/*}*/
private:
	/*{*/
	HApp ( const HApp & );
	HApp & operator = ( const HApp & );
	/*}*/
	};

class HEvtHandler : public wxEvtHandler
	{
protected:
	/*{*/
	bool	f_bRendererActive;
	wxListCtrl * f_poList;
	HRenderer f_oRenderer;
	/*}*/
public:
	/*{*/
	HEvtHandler ( wxListCtrl * );
	/*}*/
protected:
	/*{*/
	void on_key_press ( wxKeyEvent & );
	void on_list_item_select ( wxListEvent & );
	/*}*/
private:
	/*{*/
	friend class HFrame;
	HEvtHandler ( const HEvtHandler & );
	HEvtHandler & operator = ( const HEvtHandler & );
	DECLARE_EVENT_TABLE ( )
	/*}*/
	};

BEGIN_EVENT_TABLE ( HEvtHandler, wxEvtHandler )
	EVT_CHAR ( HEvtHandler::on_key_press )
	EVT_LIST_ITEM_SELECTED ( XRCID ( "LISTCTRL_FORMULAS" ), HEvtHandler::on_list_item_select )
END_EVENT_TABLE ( )

/* event tables and other macros for wxWindows */

/* the event tables connect the wxWindows events with the functions (event
 * handlers) which process them. It can be also done at run-time, but for the
 * simple menu events like this the static method is much simpler. */

BEGIN_EVENT_TABLE ( HFrame, wxFrame )
	EVT_MENU ( XRCID ( "ID_NEW" ),		HFrame::on_new )
	EVT_MENU ( XRCID ( "ID_OPEN" ),		HFrame::on_open )
	EVT_MENU ( XRCID ( "ID_SAVE" ),		HFrame::on_save )
	EVT_MENU ( XRCID ( "ID_EXIT" ),		HFrame::on_quit )
	EVT_MENU ( XRCID ( "ID_ABOUT" ),	HFrame::on_about )
	EVT_SIZE ( HFrame::on_size )
END_EVENT_TABLE ( )

/* Create a new application object: this macro will allow wxWindows to create
 * the application object during program execution (it's better than using a
 * static object for many reasons) and also implements the accessor function
 * wxGetApp() which will return the reference of the right type (i.e. HApp and
 * not wxApp) */

IMPLEMENT_APP_NO_MAIN ( HApp )
IMPLEMENT_WX_THEME_SUPPORT

/* implementation */

/* the application class */

HApp::HApp ( void ) : f_poFrame ( NULL )
	{
	M_PROLOG
	return;
	M_EPILOG
	}

HApp::~HApp ( void )
	{
	M_PROLOG
/*	if ( f_poFrame )
		delete f_poFrame; */
	f_poFrame = NULL;
	return;
	M_EPILOG
	}

/* 'Main program' equivalent: the program execution "starts" here */
bool HApp::OnInit ( void )
	{
	M_PROLOG
	/* load resources */
	wxImage::AddHandler ( new wxXPMHandler );
	wxXmlResource::Get ( )->InitAllHandlers ( );
	wxXmlResource::Get ( )->Load ( static_cast < char * > ( setup.f_oResourcePath ) );
	
	/* create the main application window */
	f_poFrame = new HFrame ( );
	f_poFrame->layout ( );

	/* success: wxApp::OnRun() will be called which will enter the main message
	 * loop and the application will run. If we returned FALSE here, the
	 * application would exit immediately. */
	return TRUE;
	M_EPILOG
	}

HFrame::HFrame ( void ) : wxFrame ( ), f_poList ( NULL ), f_poHandler ( NULL )
	{
	M_PROLOG
	return;
	M_EPILOG
	}

HFrame::~HFrame ( void )
	{
	M_PROLOG
/*
	if ( f_poHandler )
		delete f_poHandler;
*/
	f_poHandler = NULL;
	return;
	M_EPILOG
	}

void HFrame::layout ( void )
	{
	M_PROLOG
	wxXmlResource::Get ( )->LoadFrame ( this, NULL, "FRAME" );
	
	/* and show it (the frames, unlike simple controls, are not shown when
	 * created initially) */
	
	/* set the frame icon */
	wxIcon l_oIcon ( static_cast < char * > ( setup.f_oIconPath ), wxBITMAP_TYPE_XPM );
	if ( l_oIcon.Ok ( ) )
		SetIcon ( l_oIcon );

	/* set menu */
	SetMenuBar ( wxXmlResource::Get ( )->LoadMenuBar ( "MENU_MAIN" ) );
	/* set toolbar */
	SetToolBar ( wxXmlResource::Get ( )->LoadToolBar ( this,  "TOOLBAR" ) );

	f_poList = XRCCTRL ( * this, "LISTCTRL_FORMULAS", wxListCtrl );
	M_ENSURE ( f_poList );
	f_poList->InsertColumn ( 0, _ ( "Formulas" ), wxLIST_FORMAT_LEFT, 550 );
	resize_list ( );
	f_poHandler = new HEvtHandler ( f_poList );
	f_poList->PushEventHandler ( f_poHandler );
	Layout ( );

	/* create a status bar just for fun (by default with 1 pane only) */
	CreateStatusBar ( 2 );
	SetStatusText ( _ ( "Welcome to funlab " VER ) );
	Show ( TRUE );
	f_poList->SetFocus ( );
	return;
	M_EPILOG
	}

/* event handlers */
void HFrame::on_new ( wxCommandEvent & )
	{
	M_PROLOG
	f_poList->DeleteAllItems ( );
	return;
	M_EPILOG
	}

void HFrame::on_open ( wxCommandEvent & )
	{
	M_PROLOG
	wxFileDialog l_oOpenDialog ( this, _ ( "Select formulas file ..." ), "", "", _ ( "Formulas files (*.fun)|*.fun" ) );
//	l_oOpenDialog.SetWildcard ( _ ( "Formulas files (*.fun)|*.fun" ) );
	l_oOpenDialog.SetStyle ( wxOPEN | wxHIDE_READONLY );
	if ( l_oOpenDialog.ShowModal ( ) == wxID_OK )
		{
		f_poList->DeleteAllItems ( );
		open ( reinterpret_cast < char const * > ( l_oOpenDialog.GetPath ( ).c_str ( ) ) );
		}
	return;
	M_EPILOG
	}

void HFrame::on_save ( wxCommandEvent & )
	{
	M_PROLOG
	wxFileDialog l_oOpenDialog ( this, _ ( "Enter file name to save ..." ), "", "", _ ( "Formulas files (*.fun)|*.fun" ) );
//	l_oOpenDialog.SetWildcard ( _ ( "Formulas files (*.fun)|*.fun" ) );
	l_oOpenDialog.SetStyle ( wxSAVE | wxHIDE_READONLY );
	if ( l_oOpenDialog.ShowModal ( ) == wxID_OK )
		save ( reinterpret_cast < char const * > ( l_oOpenDialog.GetPath ( ).c_str ( ) ) );
	return;
	M_EPILOG
	}

void HFrame::on_quit ( wxCommandEvent & )
	{
	/* TRUE is to force the frame to close */
	wxMessageBox ( "Good bye!" );
	Close ( TRUE );
	return;
	}

void HFrame::on_about ( wxCommandEvent & )
	{
	HString l_oMsg;
	l_oMsg.format ( _ ( "The funlab program, very fancy GUI application that\n"
				"can be used for rendering function surfaces.\n"
				"Welcome to funlab %s" ), VER );

	wxMessageBox ( static_cast < char * > ( l_oMsg ),
			_ ( "About funlab" ), wxOK | wxICON_INFORMATION, this );
	return;
	}

void HFrame::open ( const HString & a_oPath )
	{
	M_PROLOG
	if ( a_oPath.is_empty ( ) )
		M_THROW ( _ ( "Empty path." ), g_iErrNo );
	int l_iIndex = 0;
	HString l_oLine;
	HFile l_oFile;
	l_oFile.open ( a_oPath );
	if ( l_oFile )
		{
		while ( l_oFile.read_line ( l_oLine, HFile::D_STRIP_NEWLINES ) >= 0 )
			f_poList->InsertItem ( l_iIndex ++, static_cast < char * > ( l_oLine ) );
		l_oFile.close ( );
		}
	f_poList->SetFocus ( );
	if ( l_iIndex )
		f_poList->SetItemState ( 0, wxLIST_STATE_SELECTED | wxLIST_STATE_FOCUSED,
				wxLIST_STATE_SELECTED | wxLIST_STATE_FOCUSED );
	return;
	M_EPILOG
	}

void HFrame::save ( const HString & a_oPath )
	{
	M_PROLOG
	if ( a_oPath.is_empty ( ) )
		M_THROW ( _ ( "Empty path." ), g_iErrNo );
	int l_iIndex = 0, l_iCount = f_poList->GetItemCount ( );
	HFile l_oFile ( HFile::D_WRITING );
	if ( l_iCount )
		{
		l_oFile.open ( a_oPath );
		if ( l_oFile )
			{
			for ( l_iIndex = 0; l_iIndex < l_iCount ; l_iIndex ++ )
				l_oFile << f_poList->GetItemText ( l_iIndex ) << endl;
			l_oFile.close ( );
			}
		}
	return;
	M_EPILOG
	}

void HFrame::resize_list ( void )
	{
	M_PROLOG
	int l_iWidth = 0;
	GetClientSize ( & l_iWidth, NULL );
	f_poList->SetColumnWidth ( 0, l_iWidth - 16 );
	return;
	M_EPILOG
	}

void HFrame::on_size ( wxSizeEvent & a_roEvent )
	{
	M_PROLOG
	OnSize ( a_roEvent );
	resize_list ( );
	return;
	M_EPILOG
	}

HEvtHandler::HEvtHandler ( wxListCtrl * a_poListCtrl )
	: f_bRendererActive ( false ), f_poList ( a_poListCtrl ), f_oRenderer ( )
	{
	M_PROLOG
	M_ASSERT ( f_poList );
	return;
	M_EPILOG
	}

void HEvtHandler::on_key_press ( wxKeyEvent & a_roEvent )
	{
	M_PROLOG
	int l_iItem = 0, l_iCount = 0, l_iCtr = 0, l_iPosition = 0;
	static char const l_pcSpace [ ] = "                                                       ";
	HString l_oFormula, l_oError, l_oArrow;
	l_iCount = f_poList->GetItemCount ( );
	switch ( a_roEvent.GetKeyCode ( ) )
		{
		case ( WXK_INSERT ):
			{
			f_poList->InsertItem ( l_iCount, "" );
			f_poList->EnsureVisible ( l_iCount );
			f_poList->SetItemState ( l_iCount, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED );
			break;
			}
		case ( WXK_DELETE ):
			{
			l_iItem = f_poList->GetNextItem ( - 1,
					wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED );
			if ( l_iItem >= 0 )
				{
				f_poList->DeleteItem ( l_iItem );
				l_iCount --;
				if ( l_iCount )
					{
					if ( l_iItem >= l_iCount )
						l_iItem --;
					f_poList->SetItemState ( l_iItem, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED );
					}
				}
			break;
			}
		case ( WXK_RETURN ):
			{
			l_iItem = f_poList->GetNextItem ( - 1,
					wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED );
			if ( l_iItem >= 0 )
				f_poList->EditLabel ( l_iItem );
			break;
			}
		case ( WXK_SPACE ):
			{
			l_iItem = f_poList->GetNextItem ( - 1,
					wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED );
			if ( l_iItem >= 0 )
				{
				l_oFormula = f_poList->GetItemText ( l_iItem ).c_str ( );
				if ( f_oRenderer.render_surface ( l_oFormula ) )
					{
					l_iPosition = f_oRenderer.error_position ( );
					for ( l_iCtr = 0; l_iCtr < l_iPosition; l_iCtr ++ )
						l_oArrow += '-';
					l_oArrow += 'v';
					l_oArrow += l_pcSpace;
					l_oFormula += l_pcSpace;
					l_oError.format ( "%s at this place:%s\n\n%s\n%s",
							static_cast < char const * > ( f_oRenderer.error ( ) ),
							l_pcSpace,
							static_cast < char * > ( l_oArrow ),
							static_cast < char * > ( l_oFormula ) );
					wxMessageDialog l_oInfo ( NULL,
							static_cast < char * > ( l_oError ),
							_ ( "Formula syntax error ..." ), wxOK );
					wxFont * l_poFont = & f_poList->GetFont ( );
					if ( l_poFont );
						l_oInfo.SetFont ( * l_poFont );
					wxWindowList * l_poList = & l_oInfo.GetChildren ( );
					if ( l_poList )
						{
						wxWindowListNode * l_poNode = l_poList->GetFirst ( );
					  while  ( l_poNode )
							{
							wxWindow * l_poWindow = l_poNode->GetData ( );
							if ( l_poWindow )
								l_poWindow->SetFont ( * l_poFont );
							l_poNode = l_poNode->GetNext ( );
							}
						}
					l_oInfo.ShowModal ( );
					}
				f_bRendererActive = true;
				}
			break;
			}
		default :
			{
			a_roEvent.Skip ( );
			break;
			}
		}
	return;
	M_EPILOG
	}

void HEvtHandler::on_list_item_select ( wxListEvent & a_roEvent )
	{
	M_PROLOG
	int l_iItem = 0;
	if ( f_bRendererActive )
		{
		l_iItem = a_roEvent.GetIndex ( );
		if ( l_iItem >= 0 )
			f_oRenderer.render_surface ( f_poList->GetItemText ( l_iItem ).c_str ( ) );
		}
	return;
	M_EPILOG
	}

